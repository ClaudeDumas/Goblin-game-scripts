using System.Collections;
using System.Collections.Generic;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using UnityEditor;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.iOS;

public class NavMeshing : MonoBehaviour
{
    [SerializeField] Vector3 StartPoint;
    [SerializeField] float xBound;
    [SerializeField] float zBound;
    [SerializeField] float upperYBound;
    [SerializeField] float lowerYBound;
    [SerializeField] float tileSize;
    [SerializeField] float stepSize;
    [SerializeField] float maxSlope;
    [SerializeField] float height;
    [SerializeField] float radius;
    [SerializeField] float jumpDistance;
    [SerializeField] bool addCubes;
    List<List<List<Point>>> pointRows = new List<List<List<Point>>>();
    void Start()
    {
        // in each column and row according to the x bounds and tile size, make a point
        // everywhere the player can stand. This includes everywhere in a y column.
        for (float i = 0; i < xBound/tileSize; i++)
        {
            List<List<Point>> row = new List<List<Point>>();
            for (float j = 0; j < zBound/tileSize; j++)
            {
                RaycastHit[] hits = Physics.RaycastAll(StartPoint + new Vector3(tileSize * i, 99999, tileSize * j), new Vector3(0, -1, 0), Mathf.Infinity);
                List<Point> yCol = new List<Point>();
                foreach (RaycastHit repeatedHit in hits)
                {
                    Vector3 capsuleLoc = repeatedHit.point + (repeatedHit.normal * ((height/2) + 0.001f));
                    // if there was a point there, would it overlap with anything?
                    if (Physics.OverlapCapsule(capsuleLoc + new Vector3(0, (height/2) - radius, 0), capsuleLoc - new Vector3(0, (height/2) - radius, 0), radius).Length == 0 && capsuleLoc.y < upperYBound && capsuleLoc.y > lowerYBound)
                    {
                        Point newPoint = new Point();
                        // need to switch capsuleLoc to repeatedHit.point + neg reciprocal of normal.
                        if (VectorAngle(capsuleLoc, repeatedHit.point) < maxSlope && VectorAngle(capsuleLoc, repeatedHit.point) > -maxSlope){
                            newPoint.set(capsuleLoc, pointType.Standable);
                        }
                        else{

                        }
                        yCol.Add(newPoint);
                        if (addCubes)
                        {
                            GameObject representativeCube = GameObject.CreatePrimitive(PrimitiveType.Cube);
                            representativeCube.transform.position = capsuleLoc;
                            representativeCube.transform.localScale = new Vector3(0.5f, 0.5f, 0.5f);
                        }
                    }
                }
                row.Add(yCol);
            }
            pointRows.Add(row);
        }
        // to solve the issue of layers, offset i and j
        // To solve the issue of moving platforms, make a point's position actually relative to the hit's object.
        // Also make it so that when it moves it changes the connections based on what can jump to it.
        for (int i = 0; i < pointRows.Count; i++)
        {
            for (int j = 0; j < pointRows[i].Count; j++)
            {
                for (int p = 0; p < pointRows[i][j].Count; p++)
                {
                    Point subjectPoint = pointRows[i][j][p];
                    // check if there's something in the way of two orthagonal points (like where the king can move in chess but not like the queen)
                    for (int k = 0; k < 9; k++)
                    {
                        // when at the lower and upper bounds of x and z on the navmesh, keeps this from accessing nonexistent points.
                        float pRow = Mathf.Clamp(i + 1 - ((k / 3) - (k / 3 % 1)), 0, pointRows.Count - 1);
                        float pCol = Mathf.Clamp(j + 1 - k % 3, 0, pointRows[i].Count - 1);
                        // for accessing everything in a column of points, because using raycastAll means there's columns of points to access.
                        for (int l = 0; l < pointRows[(int)pRow][(int)pCol].Count; l++){

                            Point connectPoint = pointRows[(int)pRow][(int)pCol][l];
                            if (connectPoint == subjectPoint){
                                continue;
                            }
                            // degrees from the point the subject is connecting to and the subject.
                            // distance formula for x and z instead of x and y to find the x of the plane I'm checking the angle on.
                            // for the y of the plane it's just the y of both angles.
                            float deg = Mathf.Atan2(connectPoint.get().y - subjectPoint.get().y, Mathf.Sqrt(Mathf.Pow(connectPoint.get().x - subjectPoint.get().x, 2) + Mathf.Pow(connectPoint.get().z - subjectPoint.get().z, 2))) * Mathf.Rad2Deg;
                            // using rHit instead of just hit because "height" is already taking up name space and it autocorrects to that
                            if (!Physics.CapsuleCast(subjectPoint.get() - new Vector3(0, height/2, 0), subjectPoint.get() + new Vector3(0, height/2, 0), radius, connectPoint.get() - subjectPoint.get(), (connectPoint.get() - subjectPoint.get()).magnitude) &&  deg < maxSlope)
                            {

                                // checking to see if you can go down to the connection but not up from it, reference other comments for how the script checks for a connection like that.
                                Vector3 yMirror = subjectPoint.get() - new Vector3(0,subjectPoint.get().y,0) + new Vector3(0, connectPoint.get().y, 0);
                                // something is wrong with the second part of this if
                                if (deg >= -maxSlope || (!Physics.Raycast(yMirror, connectPoint.get() - yMirror, (connectPoint.get() - yMirror).magnitude) && Mathf.Abs(connectPoint.get().y - subjectPoint.get().y) <= stepSize))
                                {
                                    subjectPoint.addConnection(connectPoint, navmeshConnectionType.Normal);
                                    Debug.DrawLine(subjectPoint.get(), connectPoint.get(), Color.white, Mathf.Infinity);
                                }
                                else
                                {
                                    subjectPoint.addConnection(connectPoint, navmeshConnectionType.Fall);
                                    //print("falling.");
                                    Debug.DrawLine(subjectPoint.get(), connectPoint.get(), Color.red, Mathf.Infinity);
                                }
                            }
                            else
                            {
                                // I take back the thing about steps being too small, I was wrong.

                                // y mirror is a variable that represents subjectpoint's position but at the same y as connectpoint's.
                                    // this is to get around steps that can be stepped up but not raycasted through
                                Vector3 yMirror = subjectPoint.get() - new Vector3(0,subjectPoint.get().y,0) + new Vector3(0, connectPoint.get().y, 0);
                                RaycastHit hit;
                                if (
                                    subjectPoint.get().y < connectPoint.get().y 
                                    && (connectPoint.get().y - subjectPoint.get().y) <= stepSize
                                    // First, cast the hitbox up to check if there's nothing in the way of going up.
                                    && !Physics.CapsuleCast(subjectPoint.get() + new Vector3(0, height/2, 0), subjectPoint.get() - new Vector3(0, height/2, 0), radius, yMirror - subjectPoint.get(), (yMirror - subjectPoint.get()).magnitude)
                                    // Second, cast the hitbox to the other point to see if there's nothing in the way of going forward.
                                    && !Physics.CapsuleCast(yMirror + new Vector3(0, height/2, 0), yMirror - new Vector3(0, height/2, 0), radius, connectPoint.get() - yMirror, (connectPoint.get() - yMirror).magnitude)
                                )
                                {
                                    // Third, check if there's anything in the way downward (This would mean it's on a slope)
                                    if (Physics.CapsuleCast(connectPoint.get() + new Vector3(0, height/2, 0), connectPoint.get() - new Vector3(0, height/2, 0), radius, Vector3.down, out hit, height/2)){
                                        // Fourth, get the surface's slope based on the normal and the point made.
                                        float deg2 = Mathf.Atan2(connectPoint.get().y + (1/hit.normal.y) - connectPoint.get().y, Mathf.Sqrt(Mathf.Pow(connectPoint.get().x + hit.normal.x - connectPoint.get().x, 2) + Mathf.Pow(connectPoint.get().z + hit.normal.z - connectPoint.get().z, 2))) * Mathf.Rad2Deg;
                                        if (deg2 > -maxSlope && deg2 < maxSlope)
                                        {
                                            subjectPoint.addConnection(connectPoint, navmeshConnectionType.Step);
                                            Debug.DrawLine(subjectPoint.get(), connectPoint.get(), Color.green, Mathf.Infinity);
                                        }
                                    }
                                    else{
                                        // if not, it's just a step that isn't on a slope.
                                        subjectPoint.addConnection(connectPoint, navmeshConnectionType.Step);
                                        Debug.DrawLine(subjectPoint.get(), connectPoint.get(), Color.green, Mathf.Infinity);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        // find a way to simplify the navmesh
    }
    public float VectorAngle(Vector3 to, Vector3 from){
        return Mathf.Atan2(to.y - from.y, Mathf.Sqrt(Mathf.Pow(to.x - from.x, 2) + Mathf.Pow(to.z - from.z, 2))) * Mathf.Rad2Deg;
    }
}
public class Point
{
    List<PointConnection> ConnectedPoints = new List<PointConnection>();
    public Vector3 Place;
    public pointType type;

    public void set(Vector3 spot, pointType pT)
    {
        Place = spot;
        type = pT;
    }
    public Vector3 get()
    {
        return Place;
    }
    // the f stands for friend :)
    public void addConnection(Point fPoint, navmeshConnectionType type)
    {
        PointConnection newPointConnection = new PointConnection();
        newPointConnection.set(type, fPoint);
        ConnectedPoints.Add(newPointConnection);
    }
    public List<PointConnection> getConnections()
    {
        return ConnectedPoints;
    }
}
public enum pointType{
    Standable,
    noStand
}
// type of point connection
public enum navmeshConnectionType
{
    Fall,
    Normal,
    Step
}
public class PointConnection
{
    public navmeshConnectionType type;
    public Point point;
    public void set(navmeshConnectionType t, Point p)
    {
        type = t;
        point = p;
    }
    public Vector3 get()
    {
        return point.get();
    }
    public navmeshConnectionType getType()
    {
        return type;
    }
}
